---
stepsCompleted: [1, 2, 3, 4, 5, 6, 7]
inputDocuments: 
  - 'docs/prd.md'
  - 'docs/project-planning.md'
  - 'docs/analysis/brainstorming-session-2025-12-01.md'
workflowType: 'architecture'
lastStep: 7
project_name: 'langchain'
user_name: 'Langchain Chatbot'
date: '2025-12-01'
hasProjectContext: false
---

# Architecture Decision Document

_This document builds collaboratively through step-by-step discovery. Sections are appended as we work through each architectural decision together._

## üìã Document Policy

**Code Examples Policy:**
- ‚ùå **NO detailed code examples** in this architecture document
- ‚úÖ **YES to project structure** (directory trees, file organization)
- ‚úÖ **YES to command sequences** (installation, setup, deployment commands)
- ‚úÖ **YES to configuration outlines** (what needs to be configured, not full config files)
- ‚úÖ **YES to architectural patterns** (descriptions and references, not implementations)

**Rationale:** 
- Architecture document focuses on *decisions and structure*, not implementation details
- Code examples belong in actual codebase, not documentation
- Keeps document concise, maintainable, and focused on architectural guidance
- Implementation patterns are described conceptually, AI agents generate actual code

**What This Document Contains:**
- Architectural decisions with rationale
- Technology choices with versions
- Project structure and organization
- Integration patterns and boundaries
- Setup and deployment commands
- Pattern descriptions (without code)

**What to Find Elsewhere:**
- Actual code implementations ‚Üí In project source files
- Detailed configuration files ‚Üí In project config directories
- Code examples ‚Üí Generated by AI agents following this architecture
- API implementations ‚Üí In backend/frontend source code

---

## Project Context Analysis

### Requirements Overview

**Functional Requirements:**

D·ª± √°n y√™u c·∫ßu x√¢y d·ª±ng AI Chatbot full-stack nh∆∞ m·ªôt **learning playground v√† production-ready reference architecture**. Core functionality bao g·ªìm:

- **User Management**: Registration, login v·ªõi JWT authentication, protected routes
- **Chat Interface**: Clean UI v·ªõi text input, message display (user + AI), loading indicators
- **AI Integration**: LangChain + GPT-4 integration v·ªõi conversation memory, streaming responses
- **Multi-Session Support**: Create/switch/delete chat sessions, persistent history
- **Real-time Communication**: WebSocket cho streaming AI responses, typing indicators
- **Infrastructure**: Docker Compose orchestration (frontend, backend, database, nginx proxy)

**MVP (Week 1-4)** t·∫≠p trung v√†o: Authentication, basic single-conversation chat, Docker setup.  
**Growth Features (Week 5-6)**: Multiple sessions, WebSocket streaming, responsive UI, performance optimization.  
**Vision (Future)**: RAG v·ªõi document upload, team collaboration, monitoring, Kubernetes deployment.

**Non-Functional Requirements:**

- **Performance**: 
  - AI response time < 5 seconds (p95)
  - Support 100+ concurrent users (MVP target)
  - Architecture ƒë·ªÉ scale ƒë·∫øn 1000+ users (vision)
  - Database query optimization, frontend code splitting

- **Security**:
  - JWT token authentication v·ªõi bcrypt password hashing
  - CORS configuration cho cross-origin requests
  - Rate limiting (Nginx/backend level)
  - Security headers, CSRF protection
  - Environment variable management cho secrets

- **Reliability**:
  - Docker volume persistence cho database
  - Error handling cho API failures
  - Auto-reconnection logic cho WebSocket
  - Health checks cho all services

- **Developer Experience**:
  - One-command deployment v·ªõi `docker-compose up`
  - Hot reload trong development mode
  - Comprehensive documentation (README, API docs, deployment guide)
  - Clean, commented, well-structured codebase

- **Learning Objectives**:
  - Architecture ph·∫£i d·ªÖ hi·ªÉu v√† c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng
  - Clear separation of concerns
  - Best practices demonstration
  - Reusable patterns cho future projects

**Scale & Complexity:**

- **Primary domain**: Full-Stack Web Application with AI/ML Integration
- **Complexity level**: Medium-High
  - AI integration complexity (LangChain, GPT-4, conversation memory)
  - Real-time communication (WebSocket streaming)
  - Multi-container orchestration (Docker networking, volumes)
  - Security implementation (JWT flows, password hashing)
  
- **Estimated architectural components**: 8-10 major components
  - Frontend (Next.js App Router, React components, API client)
  - Backend (FastAPI, LangChain service, Auth service)
  - Database (PostgreSQL with ORMs)
  - Reverse Proxy (Nginx routing v√† load balancing)
  - Authentication Layer (JWT middleware)
  - WebSocket Layer (Real-time communication)
  - External Integration (OpenAI API)
  - Infrastructure (Docker Compose orchestration)

### Technical Constraints & Dependencies

**Fixed Technology Choices:**
- **Frontend**: Next.js 14+ v·ªõi App Router, TypeScript, Tailwind CSS
- **Backend**: Python 3.11+, FastAPI, LangChain 0.1+
- **Database**: PostgreSQL 15+ v·ªõi SQLAlchemy ORM
- **Infrastructure**: Docker 24+, Docker Compose 2+, Nginx 1.25+
- **AI Model**: OpenAI GPT-4 via LangChain

**External Service Dependencies:**
- **OpenAI API**: 
  - Rate limits c·∫ßn x·ª≠ l√Ω (implement queuing, caching)
  - Cost considerations (usage-based ~$100-500/month)
  - API availability (error handling, fallback responses)

**Development Environment:**
- Linux/macOS recommended (Ubuntu 22.04 LTS for production)
- Git workflow v·ªõi branching strategy (main, develop, feature/*)
- VS Code workspace settings

**Known Constraints:**
- Learning project n√™n c·∫ßn balance gi·ªØa simplicity v√† production-readiness
- Budget constraint cho OpenAI API usage
- Timeline constraint: MVP trong 4 tu·∫ßn, full features 6-8 tu·∫ßn
- Team size: 2-4 developers (backend, frontend, DevOps roles)

### Cross-Cutting Concerns Identified

**1. Authentication & Authorization**
- JWT token generation, validation, refresh mechanism
- Password hashing v√† secure storage
- Protected routes trong c·∫£ frontend v√† backend
- Token storage strategy (localStorage vs httpOnly cookies)
- CORS configuration cho cross-origin requests

**2. Error Handling & Logging**
- Centralized error handling trong backend (FastAPI exception handlers)
- Frontend error boundaries v√† user-friendly error messages
- Structured logging cho troubleshooting
- Error tracking integration (Sentry - optional)
- API error response standardization

**3. Environment Configuration**
- Environment variables cho all services (DATABASE_URL, API keys, JWT secrets)
- .env file management v√† templates
- Development vs production configuration separation
- Docker Compose environment variable injection
- Security: Never commit secrets to repository

**4. API Gateway Pattern**
- Nginx reverse proxy routing:
  - `/` ‚Üí Frontend (Next.js)
  - `/api/` ‚Üí Backend (FastAPI)
  - `/api/chat/ws` ‚Üí WebSocket endpoint
- Request/response header management
- SSL/TLS termination (production)
- Rate limiting v√† security headers

**5. Database Management**
- Schema design cho users, chat_sessions, messages
- Database migrations (Alembic)
- Connection pooling v√† optimization
- Data persistence across container restarts
- Backup strategy (future)

**6. Real-Time Communication**
- WebSocket connection lifecycle management
- Message streaming protocol
- Connection state handling (connect, disconnect, reconnect)
- Error handling trong real-time contexts
- Fallback to HTTP polling n·∫øu WebSocket fails

**7. Testing Strategy**
- Unit tests cho business logic (auth, LangChain integration)
- API endpoint testing (FastAPI TestClient)
- Frontend component testing (React Testing Library)
- Integration tests cho end-to-end flows
- Load testing cho performance validation

**8. Documentation & Developer Experience**
- README v·ªõi clear setup instructions
- API documentation (OpenAPI/Swagger auto-generated)
- Architecture diagrams (system overview, data flow)
- Deployment guide v·ªõi Docker commands
- Troubleshooting common issues

---

## Starter Template Evaluation

### Primary Technology Domain

**Full-Stack Web Application with AI Integration** - Frontend (Next.js) + Backend (FastAPI) architecture v·ªõi clear separation of concerns.

### Approach: Separate Starters for Frontend & Backend

Given the fixed technology choices (Next.js frontend + FastAPI backend v·ªõi Docker orchestration), the optimal approach is using **separate official starters** rather than monolithic full-stack templates. This provides:

- Clean separation between frontend v√† backend codebases
- Easier containerization v·ªõi separate Dockerfiles
- Independent deployment v√† scaling capabilities
- Better alignment v·ªõi microservices architecture pattern

### Selected Starters

#### Frontend: Next.js Official CLI

**Initialization Command:**

```bash
npx create-next-app@latest frontend --typescript --tailwind --app --eslint --import-alias "@/*"
npm install antd @ant-design/nextjs-registry
```

**Rationale for Selection:**
- Official Next.js starter v·ªõi latest best practices (Next.js 14+, React 18+)
- Automatic setup cho all required technologies: TypeScript, Tailwind CSS, ESLint
- App Router architecture (recommended over Pages Router)
- Turbopack bundler included (faster development experience)
- Zero configuration needed - works out of the box

**Architectural Decisions Provided by Starter:**

**Language & Runtime:**
- TypeScript 5.1+ with strict mode configuration
- Node.js 20.9+ requirement
- React 18+ with Server Components support
- Import aliases (`@/*`) for clean import paths

**Styling Solution:**
- **Ant Design v5** (Primary UI component library)
  - Pre-built React components (Button, Form, Table, Modal, etc.)
  - Theme customization via ConfigProvider
  - Built-in icons (@ant-design/icons)
  - Responsive grid system
- **Tailwind CSS v3** (Utility classes for custom styling)
  - Complementary to Ant Design
  - PostCSS setup for processing
  - CSS Modules support built-in

**Build Tooling:**
- Turbopack development bundler (default, faster than Webpack)
- Webpack available as fallback for production builds
- Image optimization v·ªõi next/image
- Font optimization v·ªõi next/font
- Automatic code splitting v√† lazy loading

**Testing Framework:**
- No testing framework included by default
- Jest + React Testing Library recommended (manual setup required)
- Playwright/Cypress for E2E testing (manual setup)

**Code Organization:**
- App Router file-system based routing (`/app` directory)
- `layout.tsx` for shared layouts
- `page.tsx` for route pages
- `src/` directory option for better organization
- Recommended structure: `src/app`, `src/components`, `src/lib`

**Development Experience:**
- Hot Module Replacement (HMR) v·ªõi Turbopack
- Fast Refresh for instant feedback
- TypeScript plugin for VSCode
- ESLint integration v·ªõi Next.js rules
- `next dev` starts development server on port 3000

---

#### Backend: FastAPI Manual Setup

**Initialization Commands:**

```bash
# Create backend directory v√† virtual environment
mkdir backend && cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install core dependencies
pip install "fastapi[standard]" "langchain>=0.1.0" "openai>=1.0.0" "sqlalchemy>=2.0.0" \
            "python-jose[cryptography]" "passlib[bcrypt]" "python-multipart"

# Generate requirements.txt
pip freeze > requirements.txt
```

**Rationale for Selection:**
- FastAPI kh√¥ng c√≥ official CLI starter, nh∆∞ng manual setup cho maximum control
- Direct dependencies installation ensures latest versions
- Clear understanding of what's included trong project
- Flexibility ƒë·ªÉ structure theo learning objectives
- Follows FastAPI official documentation patterns

**Recommended Project Structure:**

```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                 # FastAPI app initialization, CORS, routers
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt.py             # JWT token utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password.py        # Password hashing
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.py          # Auth endpoints (register, login)
‚îÇ   ‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ langchain_service.py  # LangChain integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.py          # Chat endpoints
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            # User SQLAlchemy model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat_session.py   # ChatSession model
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message.py         # Message model
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            # Pydantic schemas for User
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat.py            # Pydantic schemas for Chat
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py            # Auth request/response schemas
‚îÇ   ‚îî‚îÄ‚îÄ core/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ config.py          # Settings (Pydantic BaseSettings)
‚îÇ       ‚îú‚îÄ‚îÄ database.py        # SQLAlchemy setup
‚îÇ       ‚îî‚îÄ‚îÄ dependencies.py    # FastAPI dependencies
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ README.md
```

**Architectural Decisions Provided by Manual Setup:**

**Language & Runtime:**
- Python 3.11+ v·ªõi type hints throughout
- Async/await pattern cho I/O operations
- Pydantic v2 for data validation v√† settings management
- Type checking support with mypy (optional)

**API Framework:**
- FastAPI v·ªõi automatic OpenAPI documentation
- Uvicorn ASGI server cho production
- Automatic request validation v·ªõi Pydantic
- Dependency injection pattern
- OAuth2 with Password flow cho JWT authentication

**Database & ORM:**
- SQLAlchemy 2.0+ v·ªõi async support
- PostgreSQL driver (asyncpg recommended)
- Alembic cho database migrations (setup later)
- Connection pooling configuration
- Model-first approach v·ªõi declarative base

**Authentication & Security:**
- JWT tokens v·ªõi python-jose
- Password hashing v·ªõi passlib + bcrypt
- OAuth2PasswordBearer scheme
- CORS middleware configuration
- Security headers

**LangChain Integration:**
- LangChain 0.1+ v·ªõi OpenAI integration
- ChatOpenAI for GPT-4 access
- ConversationBufferMemory for chat history
- Streaming support v·ªõi async generators
- Custom prompt templates

**Code Organization:**
- Router-based modular structure
- Separation: models (database) vs schemas (API)
- Core utilities in `/core` directory
- Service layer cho business logic
- Dependency injection cho database sessions

**Development Experience:**
- `fastapi dev` v·ªõi auto-reload
- Interactive API docs t·∫°i `/docs` (Swagger UI)
- Alternative docs t·∫°i `/redoc` (ReDoc)
- Structured logging setup
- Environment variable management v·ªõi `.env`

**Testing Setup (Manual):**
- pytest for unit v√† integration tests
- FastAPI TestClient for endpoint testing
- SQLAlchemy test database fixtures
- Async test support v·ªõi pytest-asyncio

---

### Docker Orchestration

**Note:** Project initialization v·ªõi starters ch·ªâ l√† b∆∞·ªõc ƒë·∫ßu ti√™n. Docker Compose setup s·∫Ω tie everything together:

```yaml
# docker-compose.yml structure (details in later architecture decisions)
services:
  frontend:    # Next.js container
  backend:     # FastAPI container
  database:    # PostgreSQL container
  nginx:       # Reverse proxy container
```

### Implementation Order

1. **Week 1, Day 1-2**: Initialize frontend v·ªõi `create-next-app`
2. **Week 1, Day 2-3**: Setup backend structure v√† install dependencies
3. **Week 1, Day 3-4**: Create Dockerfiles cho both services
4. **Week 1, Day 4-5**: Setup docker-compose.yml v·ªõi all services
5. **Week 2+**: Begin feature implementation

**Critical Note:** Starter templates provide foundation only. Actual architecture decisions (state management, API design, WebSocket integration, LangChain configuration) will be made in subsequent architecture decisions sections.

---

## Core Architectural Decisions

### Decision Priority Analysis

**Critical Decisions (Block Implementation):**
These decisions must be made before development can proceed effectively:
- Database schema design approach
- JWT token storage strategy
- API communication pattern (WebSocket vs HTTP)
- State management approach
- Environment variable management

**Important Decisions (Shape Architecture):**
These significantly impact architecture but can be refined during development:
- Conversation memory storage strategy
- Password requirements
- API response format
- Logging strategy

**Deferred Decisions (Post-MVP):**
Can be addressed after core functionality is working:
- Redis caching implementation
- Advanced monitoring solutions
- Kubernetes deployment configuration
- CDN integration

---

### Data Architecture

#### Decision 1.1: Database Schema Design Approach

**Decision:** Normalized Relational Schema

**Rationale:**
- Clear entity relationships v·ªõi proper foreign keys
- Data integrity enforcement at database level
- PostgreSQL handles joins efficiently at target scale (100+ concurrent users)
- Best practice for learning objectives - demonstrates proper database design
- Easier to understand, maintain, and extend

**Schema Structure:**

**Tables:**
- `users` - Authentication and profile (id, username, email, hashed_password, timestamps)
- `chat_sessions` - Conversation metadata (id, user_id FK, title, timestamps)
- `messages` - Individual messages (id, session_id FK, role enum, content, timestamp)

**Relationships:**
- users (1) ‚Üí (many) chat_sessions via user_id
- chat_sessions (1) ‚Üí (many) messages via session_id

**Constraints:**
- Foreign keys with CASCADE DELETE
- UNIQUE constraints on username and email
- ENUM constraint on message role: 'user' | 'assistant'

**Indexes for Performance:**
- idx_chat_sessions_user_id
- idx_messages_session_id
- idx_messages_created_at

**Affects:** Backend models, API design, LangChain integration, frontend data fetching

---

#### Decision 1.2: Conversation Memory Strategy

**Decision:** Database-backed Persistent Memory

**Rationale:**
- Leverages existing PostgreSQL infrastructure (no Redis needed for MVP)
- Persistent conversation history across server restarts
- Simpler implementation - fewer moving parts
- Clear upgrade path to Redis caching later if performance demands
- Messages table serves dual purpose: history display + LangChain memory

**Implementation Approach:**
- LangChain memory loads conversation history from database messages table
- Query messages filtered by session_id, ordered by created_at
- Format database messages into LangChain ConversationBufferMemory structure
- Memory refreshed on each AI request to maintain context

**Performance Consideration:** 
- Limit memory window to last 10-20 messages for MVP
- Add pagination for chat history UI
- Monitor query performance and add indexes as needed

**Affects:** Backend LangChain service, database queries, chat API endpoints

---

#### Decision 1.3: Database Migrations Approach

**Decision:** Alembic for Schema Versioning

**Rationale:**
- Industry standard for SQLAlchemy projects
- Auto-generates migration scripts from model changes
- Version-controlled schema evolution
- Reversible migrations for safe rollbacks
- Team collaboration friendly
- Essential learning tool for production-ready practices

**Setup Commands:**
```bash
# Install Alembic
pip install alembic

# Initialize Alembic in project
alembic init alembic

# Generate migration from models
alembic revision --autogenerate -m "Initial schema"

# Apply migrations
alembic upgrade head
```

**Workflow:**
1. Modify SQLAlchemy models
2. Generate migration: `alembic revision --autogenerate -m "description"`
3. Review and edit migration script
4. Apply: `alembic upgrade head`
5. Rollback if needed: `alembic downgrade -1`

**Affects:** Backend setup, database initialization, deployment process, Docker entrypoint

---

### Authentication & Security

#### Decision 2.1: JWT Token Storage Strategy

**Decision:** localStorage (Frontend)

**Rationale:**
- Simpler implementation for learning project
- Easy debugging and inspection
- Sufficient security with proper:
  - XSS protection (React escapes by default)
  - Content Security Policy headers
  - Input sanitization
- Clear upgrade path to httpOnly cookies for production
- No CORS complexity for cookies in development

**Implementation Pattern:**
- Store token in localStorage with key 'access_token'
- Provide utility functions: setToken(), getToken(), removeToken(), isAuthenticated()
- Located in frontend lib/auth.ts module

**Security Measures:**
- Token expiration: 30 minutes
- Automatic refresh on 401 responses
- Clear token on logout
- No sensitive data in token payload (only user_id)

**Future Enhancement:** Migrate to httpOnly cookies with refresh token rotation for production deployment

**Affects:** Frontend auth context, API client interceptors, logout functionality

---

#### Decision 2.2: Password Requirements

**Decision:** Moderate Security (8+ characters, mixed case + numbers)

**Rationale:**
- Balance between security and user experience
- Industry standard for most applications
- Prevents weak passwords while remaining user-friendly
- Easy validation with regex

**Requirements:**
- Minimum 8 characters
- At least one uppercase letter
- At least one lowercase letter
- At least one number
- Optional: Special characters encouraged but not required

**Validation Pattern:**
- Use regex to enforce: lowercase, uppercase, digit, minimum 8 characters
- Provide clear error messages for validation failures
- Implement in backend auth/password.py module
- Frontend validation mirrors backend rules

**Hashing:** bcrypt with cost factor 12 (already decided in starter template)

**Affects:** Registration endpoint, frontend validation, user schema

---

### API & Communication Patterns

#### Decision 3.1: API Response Format Standardization

**Decision:** FastAPI Default (Pydantic Schemas) with Error Envelope

**Rationale:**
- Leverages FastAPI's automatic validation and documentation
- Type-safe responses with Pydantic models
- Less boilerplate code
- OpenAPI schema generation automatic
- Consistent error handling with custom exception handlers

**Success Response Format:**
- Return Pydantic models directly from endpoints
- FastAPI automatically serializes to JSON with proper field names
- response_model parameter ensures type validation
- OpenAPI schema auto-generated from Pydantic models

**Error Response Format:**
- Standardized envelope: {"detail": {"message", "code", "field"?}}
- Custom HTTP exception handler in main.py
- User-friendly error messages
- Optional field parameter for validation errors

**Affects:** All API endpoints, frontend API client, error handling, OpenAPI docs

---

#### Decision 3.2: Real-time Communication Pattern

**Decision:** WebSocket for AI Response Streaming

**Rationale:**
- Bidirectional communication enables typing indicators (future)
- Native LangChain streaming support
- Industry standard for chat applications
- Better user experience with real-time feedback
- Learning opportunity for WebSocket implementation
- Fallback to HTTP polling not needed for MVP

**Implementation Pattern:**

**Backend:**
- WebSocket endpoint at /ws/{session_id}
- Accept connection, enter message loop
- Receive JSON messages from client
- Stream AI response chunks using LangChain async streaming
- Send chunks as JSON: {"type": "chunk", "content": "..."}
- Send completion signal: {"type": "done"}
- Handle disconnection gracefully

**Frontend:**
- WebSocket connection: ws://localhost/api/chat/ws/{sessionId}
- onmessage handler processes incoming chunks
- Append chunks to UI in real-time
- Finalize message on "done" signal
- Auto-reconnect logic for connection drops

**Connection Management:**
- Auto-reconnect on disconnect (max 3 retries)
- Heartbeat/ping every 30 seconds
- Graceful degradation: show error if WebSocket fails

**Nginx Configuration:**
```nginx
location /api/chat/ws {
    proxy_pass http://backend:8000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 86400;  # 24 hours
}
```

**Affects:** Backend chat router, frontend chat component, Nginx config, Docker networking

---

### Frontend Architecture

#### Decision 4.1: State Management Approach

**Decision:** React Context + Hooks (Built-in)

**Rationale:**
- Zero additional dependencies
- Sufficient for application scope:
  - Auth state (user, token, isAuthenticated)
  - Chat state (sessions, messages, activeSessionId)
- Next.js Server Components compatible
- Simple mental model for learning
- Easy to upgrade to Zustand/Redux if complexity grows

**Architecture:**

```typescript
// contexts/AuthContext.tsx
const AuthContext = createContext<AuthContextType>(undefined)

export function AuthProvider({ children }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  
  // Auth methods: login, logout, register
  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  )
}

// contexts/ChatContext.tsx
const ChatContext = createContext<ChatContextType>(undefined)

export function ChatProvider({ children }) {
  const [sessions, setSessions] = useState<ChatSession[]>([])
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null)
  const [messages, setMessages] = useState<Message[]>([])
  
  // Chat methods: createSession, sendMessage, loadSessions
  return (
    <ChatContext.Provider value={{ sessions, messages, ... }}>
      {children}
    </ChatContext.Provider>
  )
}
```

**Usage:**
```typescript
// In components
const { user, login } = useAuth()
const { messages, sendMessage } = useChat()
```

**State Structure:**
- AuthContext: Global, wraps entire app
- ChatContext: Nested inside AuthContext, only for authenticated routes
- Local component state: UI-specific state (loading, errors, form inputs)

**Affects:** App layout structure, component architecture, data flow

---

#### Decision 4.2: API Client Architecture

**Decision:** Axios with Interceptors

**Rationale:**
- Easy request/response interceptors for JWT injection
- Better error handling than Fetch API
- Familiar API and wide adoption
- Built-in request cancellation
- TypeScript support excellent

**Implementation Pattern:**

**Axios Instance Configuration (lib/api-client.ts):**
- Create axios instance with baseURL from environment variable
- Default headers: Content-Type: application/json

**Request Interceptor:**
- Automatically inject JWT token from storage into Authorization header
- Format: Bearer {token}
- Applied to all requests

**Response Interceptor:**
- Handle 401 Unauthorized responses globally
- Clear token from storage
- Redirect to /login page
- Propagate other errors for component-level handling

**API Service Layer Pattern (services/*.service.ts):**
- Organize API calls by domain: authService, chatService, userService
- Each service exports methods that use apiClient instance
- Type-safe with TypeScript interfaces
- Example methods: login(), register(), sendMessage(), getSessions()

**Error Handling Pattern:**
- Use try-catch blocks in components
- Check if error is AxiosError
- Extract message from error.response?.data?.detail?.message
- Display user-friendly error messages
- Set error state for UI display

**Affects:** All API calls, authentication flow, error handling, TypeScript types

---

### Infrastructure & Deployment

#### Decision 5.1: Environment Variable Management

**Decision:** .env Files with .env.example Template

**Rationale:**
- Clear documentation of required variables
- Git-safe (never commit .env, always commit .env.example)
- Docker Compose native support
- Easy for team onboarding
- Standard practice across industry

**Structure:**

```bash
# .env.example (committed to git)
# Database
DATABASE_URL=postgresql+asyncpg://user:password@db:5432/chatbot
POSTGRES_USER=chatbot_user
POSTGRES_PASSWORD=your_secure_password
POSTGRES_DB=chatbot

# JWT
SECRET_KEY=your-secret-key-min-32-characters
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# OpenAI
OPENAI_API_KEY=sk-your-api-key

# CORS
ALLOWED_ORIGINS=http://localhost:3000,http://localhost

# Frontend
NEXT_PUBLIC_API_URL=http://localhost/api
```

```bash
# .env (created by developer, never committed)
# Copy from .env.example and fill in actual values
```

**Docker Compose Integration:**
- Use env_file directive to load .env file
- Pass specific environment variables to services
- Backend receives: DATABASE_URL, SECRET_KEY, OPENAI_API_KEY
- Frontend receives: NEXT_PUBLIC_API_URL, NEXT_PUBLIC_WS_URL

**Setup Instructions:**
1. Copy .env.example to .env
2. Generate SECRET_KEY: `openssl rand -hex 32`
3. Fill in OPENAI_API_KEY, POSTGRES_PASSWORD, other secrets
4. Never commit .env to git (.gitignore includes it)

**Affects:** All services, deployment process, documentation, CI/CD

---

#### Decision 5.2: Logging Strategy

**Decision:** Python Standard Logging Module (Backend) + Console (Frontend)

**Rationale:**
- Python logging module is standard library - no dependencies
- Structured logging with configurable levels
- Easy integration with monitoring tools later
- JSON formatting option for production
- Frontend console.log adequate for MVP (upgrade to winston/pino later)

**Backend Logging Pattern:**
- Use Python standard logging module (built-in, no dependencies)
- Configure in core/logging_config.py
- Format: timestamp - module - level - message
- Handlers: StreamHandler (stdout), FileHandler (logs/app-{date}.log)
- Usage: logger = logging.getLogger(__name__) in each module
- Include extra context: user_id, request_id, etc.
- Set exc_info=True for exceptions to capture stack traces

**Log Levels:**
- DEBUG: Detailed diagnostic information
- INFO: General informational messages (user actions, API calls)
- WARNING: Warning messages (rate limit approaching, retries)
- ERROR: Error messages (API failures, validation errors)
- CRITICAL: Critical errors (database connection lost)

**Frontend Logging (MVP):**
- Use console.log/error/warn for MVP (simple, built-in)
- Wrapper in lib/logger.ts for consistent format
- Upgrade to winston/pino for production if needed

**Docker Logging:**
- Configure log drivers in docker-compose.yml
services:
  backend:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

**Affects:** Backend main.py initialization, error handling, debugging, production monitoring

---

### Decision Impact Analysis

**Implementation Sequence:**

1. **Week 1 - Foundation:**
   - Setup environment variables (.env)
   - Initialize database with Alembic migrations
   - Implement normalized schema (users, chat_sessions, messages)

2. **Week 2 - Authentication:**
   - JWT token generation with localStorage storage
   - Password validation (8+ chars, mixed case + numbers)
   - Axios client with interceptors

3. **Week 3 - Chat Core:**
   - Database-backed conversation memory
   - WebSocket implementation for streaming
   - React Context for state management

4. **Week 4 - Polish:**
   - Logging setup (Python logging module)
   - Error handling standardization
   - API response format consistency

**Cross-Component Dependencies:**

```
Database Schema (Decision 1.1)
  ‚Üì depends on
JWT Storage (Decision 2.1) ‚Üí API Client (Decision 4.2)
  ‚Üì depends on
WebSocket Pattern (Decision 3.2) ‚Üí Frontend State (Decision 4.1)
  ‚Üì depends on
Conversation Memory (Decision 1.2)
  ‚Üì depends on
Environment Variables (Decision 5.1) ‚Üí All Components
```

**Technology Version Summary:**

| Component | Technology | Version | Decision Source |
|-----------|------------|---------|----------------|
| Frontend Framework | Next.js | 14+ | Starter Template |
| Language (FE) | TypeScript | 5.1+ | Starter Template |
| UI Components | Ant Design | 5.x | Fixed Constraint |
| Styling | Tailwind CSS | 3.x | Starter Template |
| Backend Framework | FastAPI | Latest | Starter Template |
| Language (BE) | Python | 3.11+ | Starter Template |
| Database | PostgreSQL | 15+ | Fixed Constraint |
| ORM | SQLAlchemy | 2.0+ | Starter Template |
| Migrations | Alembic | Latest | Decision 1.3 |
| AI Framework | LangChain | 0.1+ | Fixed Constraint |
| LLM | GPT-4 | via OpenAI API | Fixed Constraint |
| Auth | JWT + bcrypt | Latest | Starter Template |
| API Client | Axios | Latest | Decision 4.2 |
| State Management | React Context | Built-in | Decision 4.1 |
| Real-time | WebSocket | Native | Decision 3.2 |

**Risk Mitigation:**

- **Database Performance:** Indexes on foreign keys, monitor query times, add caching if needed
- **WebSocket Stability:** Implement auto-reconnect, fallback error messages
- **OpenAI Rate Limits:** Implement request queuing, cache common responses
- **JWT Security:** Regular token expiration, clear on logout, upgrade to httpOnly cookies for production
- **State Management Complexity:** Start simple with Context, refactor to Zustand if state grows unwieldy

---

## Implementation Patterns & Consistency Rules

**üìã Section Policy:**
- This section describes **patterns and rules**, not full code implementations
- **Correct/Incorrect examples** show pattern application, not production code
- **Directory trees** are kept (essential for project structure)
- **Setup commands** are kept (essential for initialization)
- Full code belongs in actual project files, not this architecture doc

### Overview

This section defines **mandatory implementation patterns** that all AI agents and developers MUST follow to ensure code consistency, compatibility, and seamless integration across the full-stack application.

**Purpose:** Prevent conflicts when multiple AI agents or developers work on different parts of the system by establishing clear, unambiguous patterns for:
- Naming conventions (database, API, code, files)
- Project structure and organization
- Data format standards
- Communication patterns
- Error handling approaches

**Critical Conflict Points Identified:** 18 areas where inconsistent decisions could cause integration failures.

---

### Naming Patterns

#### Database Naming Conventions

**Pattern:** PostgreSQL `snake_case` convention throughout

**Tables:**
- ‚úÖ CORRECT: `users`, `chat_sessions`, `messages`
- ‚ùå WRONG: `Users`, `ChatSessions`, `Message`
- **Rule:** Plural nouns, lowercase, snake_case

**Columns:**
- ‚úÖ CORRECT: `user_id`, `created_at`, `hashed_password`, `is_active`
- ‚ùå WRONG: `userId`, `createdAt`, `hashedPassword`, `isActive`
- **Rule:** snake_case for all columns

**Foreign Keys:**
- ‚úÖ CORRECT: `user_id`, `session_id`
- ‚ùå WRONG: `userId`, `fk_user`, `user`
- **Rule:** `{referenced_table_singular}_id` format

**Indexes:**
- ‚úÖ CORRECT: `idx_users_username`, `idx_messages_session_id`, `idx_users_email`
- ‚ùå WRONG: `users_username_index`, `messages_sessionId_idx`
- **Rule:** `idx_{table}_{column}` format

**Constraints:**
- ‚úÖ CORRECT: `users_username_key`, `users_email_key`
- ‚ùå WRONG: `unique_username`, `email_constraint`
- **Rule:** Auto-generated by PostgreSQL (don't override)

**Example Schema:**
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);

CREATE TABLE chat_sessions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) DEFAULT 'New Chat',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_chat_sessions_user_id ON chat_sessions(user_id);
```

---

#### API Naming Conventions

**Pattern:** RESTful conventions with plural resources

**Endpoints:**
- ‚úÖ CORRECT: `/api/users`, `/api/chat/sessions`, `/api/chat/messages`
- ‚ùå WRONG: `/api/user`, `/api/chatSession`, `/api/message`
- **Rule:** Plural nouns for collections, nested resources for relationships

**Path Parameters:**
- ‚úÖ CORRECT: `/api/users/{user_id}`, `/api/chat/sessions/{session_id}/messages`
- ‚ùå WRONG: `/api/users/:userId`, `/api/users/<int:user_id>`, `/api/users/{id}`
- **Rule:** `{resource_singular_id}` format in documentation, framework-specific in code

**Query Parameters:**
- ‚úÖ CORRECT: `?user_id=123&limit=20&offset=0&sort=created_at_desc`
- ‚ùå WRONG: `?userId=123&pageSize=20&page=1&sortBy=createdAt`
- **Rule:** snake_case for query params

**HTTP Methods Standard Usage:**
- `GET /api/users` - List all users
- `POST /api/users` - Create new user
- `GET /api/users/{user_id}` - Get specific user
- `PUT /api/users/{user_id}` - Full update user
- `PATCH /api/users/{user_id}` - Partial update user
- `DELETE /api/users/{user_id}` - Delete user

---

#### Code Naming Conventions

**Frontend (TypeScript/React):**

**Files:**
- ‚úÖ CORRECT: `ChatInterface.tsx`, `MessageBubble.tsx`, `useAuth.ts`, `api-client.ts`
- ‚ùå WRONG: `chatInterface.tsx`, `message_bubble.tsx`, `UseAuth.ts`, `apiClient.ts`
- **Rule:** PascalCase for components (.tsx), kebab-case for utilities/libs (.ts)

**Components:**
- ‚úÖ CORRECT: `ChatInterface`, `MessageBubble`, `AuthGuard`, `Button`
- ‚ùå WRONG: `chatInterface`, `message-bubble`, `authGuard`
- **Rule:** PascalCase for React components

**Functions:**
- ‚úÖ CORRECT: `sendMessage`, `getUserData`, `handleSubmit`, `formatTimestamp`
- ‚ùå WRONG: `SendMessage`, `get_user_data`, `HandleSubmit`
- **Rule:** camelCase for functions

**Variables:**
- ‚úÖ CORRECT: `userId`, `isLoading`, `messageCount`, `sessionId`
- ‚ùå WRONG: `user_id`, `IsLoading`, `message_count`, `SessionId`
- **Rule:** camelCase for variables

**Constants:**
- ‚úÖ CORRECT: `API_BASE_URL`, `MAX_MESSAGE_LENGTH`, `TOKEN_EXPIRE_MINUTES`
- ‚ùå WRONG: `apiBaseUrl`, `max_message_length`, `TokenExpireMinutes`
- **Rule:** SCREAMING_SNAKE_CASE for constants

**Hooks:**
- ‚úÖ CORRECT: `useAuth`, `useChat`, `useWebSocket`, `useLocalStorage`
- ‚ùå WRONG: `UseAuth`, `use_chat`, `use-websocket`
- **Rule:** camelCase starting with `use` prefix

**Types/Interfaces:**
- ‚úÖ CORRECT: `User`, `ChatSession`, `Message`, `AuthContextType`
- ‚ùå WRONG: `user`, `chatSession`, `IUser`, `TMessage`
- **Rule:** PascalCase, no prefixes (I, T)

**Example Pattern:**
```typescript
// types/auth.types.ts - Use PascalCase for interfaces
export interface User { id: number; username: string; email: string; }
export interface LoginCredentials { username: string; password: string; }

// hooks/useAuth.ts - Use camelCase starting with 'use'
export const useAuth = () => {
  const [user, setUser] = useState<User | null>(null);
  const login = async (credentials: LoginCredentials) => { ... };
  return { user, login };
};

// components/ChatInterface.tsx - PascalCase components, SCREAMING_SNAKE_CASE constants
export function ChatInterface({ sessionId }: Props) {
  const MAX_MESSAGE_LENGTH = 2000;
  return <div>...</div>;
}
```

**Backend (Python/FastAPI):**

**Files:**
- ‚úÖ CORRECT: `user.py`, `chat_service.py`, `jwt_handler.py`, `auth_router.py`
- ‚ùå WRONG: `User.py`, `chatService.py`, `JWTHandler.py`, `auth-router.py`
- **Rule:** snake_case for all Python files

**Classes:**
- ‚úÖ CORRECT: `User`, `ChatSession`, `Message`, `ChatChainFactory`
- ‚ùå WRONG: `user`, `chat_session`, `chatChainFactory`
- **Rule:** PascalCase for classes

**Functions:**
- ‚úÖ CORRECT: `get_user_by_id`, `create_access_token`, `verify_password`, `hash_password`
- ‚ùå WRONG: `getUserById`, `CreateAccessToken`, `verifyPassword`
- **Rule:** snake_case for functions

**Variables:**
- ‚úÖ CORRECT: `user_id`, `session_id`, `is_active`, `created_at`
- ‚ùå WRONG: `userId`, `sessionId`, `isActive`, `createdAt`
- **Rule:** snake_case for variables

**Constants:**
- ‚úÖ CORRECT: `SECRET_KEY`, `ALGORITHM`, `ACCESS_TOKEN_EXPIRE_MINUTES`
- ‚ùå WRONG: `secret_key`, `Algorithm`, `accessTokenExpireMinutes`
- **Rule:** SCREAMING_SNAKE_CASE for constants

**Example Pattern:**
```python
# models/user.py - PascalCase for classes, snake_case columns
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)

# auth/jwt_handler.py - SCREAMING_SNAKE_CASE constants
SECRET_KEY = settings.secret_key
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Functions use snake_case
def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

# services/user_service.py
async def get_user_by_username(db: Session, username: str) -> User | None:
    return db.query(User).filter(User.username == username).first()
```
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# services/user_service.py
async def get_user_by_username(db: Session, username: str) -> User | None:
    return db.query(User).filter(User.username == username).first()
```

---

### Structure Patterns

#### Project Organization

**Frontend Structure:**
```
frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/                    # Next.js App Router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx         # Root layout with AntdRegistry
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Home page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ (auth)/            # Auth route group
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register/page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat/              # Chat routes
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [sessionId]/page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ components/            # Feature components using Ant Design
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/             # LoginForm, RegisterForm, AuthGuard
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat/             # ChatInterface, MessageBubble, etc.
‚îÇ   ‚îú‚îÄ‚îÄ lib/                   # Core utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-client.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocket.ts
‚îÇ   ‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useChat.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useWebSocket.ts
‚îÇ   ‚îú‚îÄ‚îÄ types/                 # TypeScript definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.types.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat.types.ts
‚îÇ   ‚îî‚îÄ‚îÄ utils/                 # Helpers
‚îÇ       ‚îú‚îÄ‚îÄ validators.ts
‚îÇ       ‚îî‚îÄ‚îÄ formatters.ts
‚îú‚îÄ‚îÄ public/                    # Static assets
‚îî‚îÄ‚îÄ __tests__/                 # Tests
```

**Backend Structure:**
```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                # FastAPI app entry
‚îÇ   ‚îú‚îÄ‚îÄ config.py              # Settings management
‚îÇ   ‚îú‚îÄ‚îÄ dependencies.py        # Shared dependencies
‚îÇ   ‚îú‚îÄ‚îÄ auth/                  # Auth module
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt_handler.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.py
‚îÇ   ‚îú‚îÄ‚îÄ chat/                  # Chat module
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ langchain_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.py
‚îÇ   ‚îú‚îÄ‚îÄ models/                # SQLAlchemy models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat_session.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message.py
‚îÇ   ‚îú‚îÄ‚îÄ schemas/               # Pydantic schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py
‚îÇ   ‚îú‚îÄ‚îÄ services/              # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat_service.py
‚îÇ   ‚îú‚îÄ‚îÄ database/              # Database configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/                 # Helper utilities
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ logger.py
‚îÇ       ‚îî‚îÄ‚îÄ exceptions.py
‚îú‚îÄ‚îÄ tests/                     # Test directory
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py
‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py
‚îÇ   ‚îî‚îÄ‚îÄ test_chat.py
‚îî‚îÄ‚îÄ alembic/                   # Database migrations
    ‚îú‚îÄ‚îÄ versions/
    ‚îî‚îÄ‚îÄ env.py
```

**Key Principles:**
- ‚úÖ **Separation by concern** (models, schemas, services, routers)
- ‚úÖ **Co-location of related files** (router + service in same module folder)
- ‚úÖ **Clear naming** (folder names match their purpose)
- ‚ùå **No mixed concerns** (don't put models in routers folder)

---

#### Test Organization Pattern

**Frontend Tests:**
- ‚úÖ CORRECT: Co-located with component files
  ```
  components/
  ‚îú‚îÄ‚îÄ ChatInterface.tsx
  ‚îú‚îÄ‚îÄ ChatInterface.test.tsx
  ‚îú‚îÄ‚îÄ MessageBubble.tsx
  ‚îî‚îÄ‚îÄ MessageBubble.test.tsx
  ```
- **Rule:** `{ComponentName}.test.tsx` next to component file

**Backend Tests:**
- ‚úÖ CORRECT: Mirror structure in `tests/` directory
  ```
  tests/
  ‚îú‚îÄ‚îÄ test_auth.py           # Tests for auth module
  ‚îú‚îÄ‚îÄ test_chat.py           # Tests for chat module
  ‚îú‚îÄ‚îÄ test_models.py         # Tests for models
  ‚îî‚îÄ‚îÄ integration/
      ‚îî‚îÄ‚îÄ test_api_flow.py
  ```
- **Rule:** `test_{module_name}.py` matching module structure

---

### Format Patterns

#### API Response Format

**Success Response (Direct Pydantic Model):**
```python
# Backend
@router.get("/api/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = await get_user_by_id(user_id)
    return user  # FastAPI automatically serializes to JSON

# Response:
{
  "id": 1,
  "username": "johndoe",
  "email": "john@example.com",
  "isActive": true,
  "createdAt": "2025-12-01T10:00:00Z"
}
```

**Error Response (Standardized Envelope):**
```python
# Backend - Custom exception handler
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "detail": {
                "message": exc.detail,
                "code": f"ERROR_{exc.status_code}",
                "timestamp": datetime.utcnow().isoformat()
            }
        }
    )

# Error Response:
{
  "detail": {
    "message": "User not found",
    "code": "ERROR_404",
    "timestamp": "2025-12-01T10:00:00Z"
  }
}
```

**Frontend Error Handling:**
```typescript
try {
  const response = await apiClient.get('/api/users/123');
  // Use response.data directly
} catch (error) {
  if (axios.isAxiosError(error)) {
    const errorMessage = error.response?.data?.detail?.message || 'An error occurred';
    console.error(errorMessage);
  }
}
```

**Rules:**
- ‚úÖ Success: Return Pydantic model directly, FastAPI handles serialization
- ‚úÖ Error: Always use `detail` envelope with `message`, `code`, `timestamp`
- ‚ùå Don't wrap success responses in `{success: true, data: ...}`
- ‚ùå Don't use inconsistent error formats

---

#### JSON Field Naming

**Frontend to Backend:**
- ‚úÖ CORRECT: Frontend sends `camelCase`, Backend receives and converts to `snake_case`
- **Rule:** Pydantic handles conversion automatically with `alias`

**Example:**
```python
# Backend Schema
class UserCreate(BaseModel):
    username: str
    email: str
    password: str
    
    class Config:
        # Automatically convert camelCase from frontend to snake_case
        populate_by_name = True

# Frontend sends:
{
  "username": "johndoe",
  "email": "john@example.com",
  "password": "SecurePass123!"
}

# Backend receives as snake_case (Python convention)
```

**Backend to Frontend:**
```python
# Pydantic automatically converts snake_case ‚Üí camelCase
class UserResponse(BaseModel):
    id: int
    username: str
    is_active: bool
    created_at: datetime

# Frontend receives: { "id": 1, "username": "john", "isActive": true, "createdAt": "2025-12-01T10:00:00Z" }
```

**Rules:**
- ‚úÖ Frontend: `camelCase` for all JSON fields
- ‚úÖ Backend Python: `snake_case` for all variables
- ‚úÖ Database: `snake_case` for all columns
- ‚úÖ Automatic conversion via Pydantic

---

#### Date/Time Format

**Storage:** `TIMESTAMP` columns with UTC timezone
**API Transport:** ISO 8601 strings (`"2025-12-01T10:00:00Z"`)

**Backend:**
```python
created_at = datetime.utcnow()  # Always UTC
created_at_iso = created_at.isoformat() + 'Z'
```

**Frontend:**
```typescript
interface User { createdAt: string; }  // ISO 8601 string
const date = new Date(user.createdAt);  // Convert for display
const formatted = date.toLocaleDateString('vi-VN', { year: 'numeric', month: 'long', day: 'numeric' });
```

**Rules:**
- ‚úÖ Store in UTC, transport as ISO 8601, convert to local for display
- ‚ùå Never store timestamps as integers or use local timezone in DB

---

### Communication Patterns

#### Loading State Management

**Pattern:** Boolean `isLoading` with Ant Design Spin/Button loading prop

**Frontend:**
```typescript
const [isLoading, setIsLoading] = useState(false);

const handleSubmit = async () => {
  setIsLoading(true);
  try {
    await sendMessage(text);
  } finally {
    setIsLoading(false);
  }
};

// Using Ant Design Button with loading prop
<Button type="primary" loading={isLoading} onClick={handleSubmit}>
  Submit
</Button>

// Or use Spin component
{isLoading && <Spin tip="Loading..." />}
```

**Rules:**
- ‚úÖ Use `isLoading` boolean (not `status: 'loading'`)
- ‚úÖ Always reset in `finally` block
- ‚úÖ Use Ant Design's built-in loading props
- ‚ùå Don't create custom loading states when Ant Design provides them

---

#### Error Handling Pattern

**Backend:**
```python
@router.post("/api/auth/login")
async def login(credentials: LoginRequest):
    try:
        user = await authenticate_user(credentials.username, credentials.password)
        if not user:
            raise HTTPException(status_code=401, detail="Invalid credentials")
        token = create_access_token({"sub": user.username})
        return {"access_token": token, "token_type": "bearer"}
    except Exception as e:
        logger.error(f"Login error: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="An unexpected error occurred")
```

**Frontend (Using Ant Design message):**
```typescript
import { message } from 'antd';

const handleLogin = async () => {
  try {
    await authService.login(credentials);
const handleLogin = async () => {
  setError(null);
    message.success('Login successful');
    router.push('/chat');
  } catch (err) {
    message.error(getErrorMessage(err));  // Use Ant Design message component
  }
};

// Utility function
const getErrorMessage = (error: unknown): string => {
  if (axios.isAxiosError(error)) {
    return error.response?.data?.detail?.message || 'An error occurred';
  }
  return 'An unexpected error occurred';
};
```

**Rules:**
- ‚úÖ Always use try-catch-finally
- ‚úÖ Log errors on backend with context
- ‚úÖ Use Ant Design message for user-friendly notifications
- ‚ùå Never expose stack traces to users

---

### Process Patterns

#### Authentication Flow Pattern

**Backend:**
```python
def create_access_token(data: dict) -> str:
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = data.copy() | {"exp": expire}
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

# Protected endpoint dependency
async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    user = get_user_by_username(db, payload.get("sub"))
    if not user:
        raise HTTPException(status_code=401, detail="Invalid token")
    return user
```

**Frontend (Axios interceptors):**
```typescript
// Request interceptor: Add JWT token
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token');
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

// Response interceptor: Handle 401
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('access_token');
      router.push('/login');
    }
    return Promise.reject(error);
  }
);
```

**Rules:**
- ‚úÖ OAuth2 Password Bearer flow
- ‚úÖ Token in localStorage (upgrade to httpOnly cookie for production)
- ‚úÖ Auto-inject token via interceptor
- ‚úÖ Handle 401 globally
- ‚ùå Never send token in URL

---

### Enforcement Guidelines

#### All AI Agents and Developers MUST:

1. **Follow naming conventions** - snake_case (DB/Backend), camelCase (Frontend)
2. **Use Ant Design components** - Don't create custom UI when Ant Design has it
3. **Use standardized file organization** - Follow defined structure
4. **Implement error handling** - try-catch-finally + Ant Design message
5. **Use ISO 8601 for dates** - UTC storage, ISO transport
6. **Use isLoading boolean** - Leverage Ant Design loading props
7. **Co-locate tests** - .test.tsx next to component
8. **Constants use SCREAMING_SNAKE_CASE**
9. **Database migrations use Alembic**
10. **Never hardcode secrets**

#### Pattern Checklist:

- [ ] File names: PascalCase.tsx, snake_case.py
- [ ] Variables: camelCase (TS), snake_case (Python)
- [ ] API endpoints: plural nouns (/api/users)
- [ ] Error handling: try-catch-finally
- [ ] Loading states: isLoading boolean with Ant Design
- [ ] Dates: ISO 8601 strings
- [ ] Tests properly named/located
- [ ] TypeScript types defined

#### Updating Patterns:

If a pattern needs to change:
1. Propose change with rationale to team
2. Update this documentation section
3. Update all existing code to match new pattern
4. Update linting rules and tests
5. Notify all team members and AI agents

---

### Pattern Examples & Anti-Patterns

#### ‚úÖ Good Example: User Registration Flow

**Backend Schema & Router:**
```python
# schemas/auth.py
class UserRegister(BaseModel):
    username: str = Field(min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(min_length=8)

# routers/auth.py
@router.post("/api/auth/register", response_model=UserResponse, status_code=201)
async def register_user(user_data: UserRegister, db: Session = Depends(get_db)):
    # Validate uniqueness, hash password, create user
    # Handle errors with try-except-finally
```

**Frontend Form (Using Ant Design):**
```typescript
// types/auth.types.ts
export interface RegisterData {
  username: string;
  email: string;
  password: string;
}

// app/register/page.tsx
import { Form, Input, Button, message } from 'antd';

export default function RegisterPage() {
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = async (values: RegisterData) => {
    setLoading(true);
    try {
      await authService.register(values);
      message.success('Registration successful');
      router.push('/login');
    } catch (error) {
      message.error(getErrorMessage(error));
    } finally {
      setLoading(false);
    }
  };

  return (
    <Form form={form} onFinish={handleSubmit} layout="vertical">
      <Form.Item name="username" rules={[{ required: true, min: 3 }]}>
        <Input placeholder="Username" />
      </Form.Item>
      <Form.Item name="email" rules={[{ required: true, type: 'email' }]}>
        <Input placeholder="Email" />
      </Form.Item>
      <Form.Item name="password" rules={[{ required: true, min: 8 }]}>
        <Input.Password placeholder="Password" />
      </Form.Item>
      <Button type="primary" htmlType="submit" loading={loading} block>
        Register
      </Button>
    </Form>
  );
}
```

#### ‚ùå Anti-Pattern Examples

**Wrong Naming:**
```python
# ‚ùå Database: Mixed case
class User(Base):
    __tablename__ = "Users"  # Should be "users"
    userName = Column(String)  # Should be "username"

# ‚ùå API: Wrong format
@router.get("/api/User/{id}")  # Should be "/api/users/{user_id}"
async def GetUser(id: int):    # Should be "get_user" with "user_id"
```

**Wrong Error Handling:**
```typescript
// ‚ùå No finally block, errors swallowed
try {
  await apiClient.login(credentials);
  setLoading(false);  // Won't execute if error
} catch (err) {
  // No error handling!
}

// ‚úÖ Correct pattern
try {
  await apiClient.login(credentials);
} catch (err) {
  message.error(getErrorMessage(err));
} finally {
  setLoading(false);
}
```

**Wrong State Management:**
```typescript
// ‚ùå String-based status
const [status, setStatus] = useState<'idle' | 'loading'>('idle');

// ‚úÖ Boolean pattern
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
```

---

### Summary

These implementation patterns ensure:
- ‚úÖ **Consistency:** All code follows same conventions
- ‚úÖ **Compatibility:** Frontend and backend communicate seamlessly
- ‚úÖ **Maintainability:** New developers/agents understand structure immediately
- ‚úÖ **Quality:** Best practices embedded in patterns
- ‚úÖ **Scalability:** Patterns support growth without refactoring

**Remember:** These patterns are **mandatory**, not suggestions. Following them prevents integration conflicts and ensures code quality across the entire application.

---

## Project Structure & Boundaries

### Complete Project Directory Structure

```
langchain/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ docker-compose.prod.yml
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ package-lock.json
‚îÇ   ‚îú‚îÄ‚îÄ next.config.js
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îú‚îÄ‚îÄ postcss.config.js
‚îÇ   ‚îú‚îÄ‚îÄ .eslintrc.json
‚îÇ   ‚îú‚îÄ‚îÄ .env.local
‚îÇ   ‚îú‚îÄ‚îÄ .env.example
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ .dockerignore
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ globals.css
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ not-found.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ error.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [sessionId]/
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx        # Uses Ant Design Form, Input, Button
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegisterForm.tsx     # Uses Ant Design Form components
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AuthGuard.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ChatInterface.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ChatInterface.test.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MessageBubble.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MessageBubble.test.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ChatInput.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ChatInput.test.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ChatHistory.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SessionList.tsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TypingIndicator.tsx
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-client.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ websocket.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ constants.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useAuth.test.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useChat.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useWebSocket.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useLocalStorage.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.types.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat.types.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ common.types.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validators.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatters.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ date-helpers.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ favicon.ico
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ icons/
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ       ‚îú‚îÄ‚îÄ integration/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ auth-flow.test.tsx
‚îÇ       ‚îî‚îÄ‚îÄ e2e/
‚îÇ           ‚îî‚îÄ‚îÄ chat.spec.ts
‚îÇ
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ requirements-dev.txt
‚îÇ   ‚îú‚îÄ‚îÄ pyproject.toml
‚îÇ   ‚îú‚îÄ‚îÄ pytest.ini
‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îú‚îÄ‚îÄ .env.example
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ .dockerignore
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dependencies.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt_handler.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ websocket.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat_session.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ common.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat_service.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth_service.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ langchain_core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chain.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompts.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ callbacks.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base.py
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ exceptions.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conftest.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_chat.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_langchain.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ test_api_flow.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ alembic/
‚îÇ       ‚îú‚îÄ‚îÄ alembic.ini
‚îÇ       ‚îú‚îÄ‚îÄ env.py
‚îÇ       ‚îú‚îÄ‚îÄ script.py.mako
‚îÇ       ‚îî‚îÄ‚îÄ versions/
‚îÇ           ‚îî‚îÄ‚îÄ .gitkeep
‚îÇ
‚îú‚îÄ‚îÄ nginx/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ nginx.conf
‚îÇ   ‚îî‚îÄ‚îÄ ssl/
‚îÇ       ‚îî‚îÄ‚îÄ .gitkeep
‚îÇ
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îî‚îÄ‚îÄ init-db.sql
‚îÇ
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ architecture.md
    ‚îú‚îÄ‚îÄ prd.md
    ‚îú‚îÄ‚îÄ project-planning.md
    ‚îú‚îÄ‚îÄ api/
    ‚îÇ   ‚îî‚îÄ‚îÄ endpoints.md
    ‚îî‚îÄ‚îÄ deployment/
        ‚îî‚îÄ‚îÄ production-setup.md
```

### Architectural Boundaries

#### API Boundaries

**External API Gateway:**
- **Nginx Reverse Proxy** (ports 80/443) serves as single entry point
- Routes frontend requests to Next.js service (port 3000)
- Routes API requests (`/api/*`) to FastAPI backend (port 8000)
- Handles SSL termination, load balancing, rate limiting

**Frontend ‚Üî Backend Communication:**
- **Protocol:** HTTP REST API + WebSocket
- **Base URL:** `http://nginx/api` (development) or `https://yourdomain.com/api` (production)
- **Authentication:** Bearer token in `Authorization` header
- **Data Format:** JSON with camelCase fields (frontend) ‚Üî snake_case fields (backend)

**Authentication Boundary:**
- **Entry Point:** `backend/app/auth/dependencies.py::get_current_user()`
- **Enforcement:** FastAPI Depends() on protected routes
- **Token Validation:** JWT signature verification + expiration check
- **User Resolution:** Load user from database based on token payload

**WebSocket Boundary:**
- **Endpoint:** `/api/chat/ws?token={access_token}`
- **Protocol:** WebSocket over HTTP/HTTPS
- **Authentication:** Token passed as query parameter
- **Message Format:** JSON with `type` and payload fields

**Database Access Boundary:**
- **Entry Point:** `backend/app/database/session.py::get_db()`
- **Isolation:** SQLAlchemy ORM only, no raw SQL queries
- **Connection Pooling:** Managed by SQLAlchemy engine
- **Transaction Management:** Commit/rollback in service layer

#### Component Boundaries

**Frontend Component Hierarchy:**
```
App Router (Next.js)
  ‚îî‚îÄ> Page Components (app/*.tsx)
       ‚îî‚îÄ> Feature Components (components/chat/, components/auth/)
            ‚îî‚îÄ> Ant Design Components (Button, Form, Input, Modal, etc.)
```

**Rules:**
- ‚úÖ Pages can use feature components and Ant Design components directly
- ‚úÖ Feature components use Ant Design components (Button, Form, Input, Modal, Table, etc.)
- ‚ùå Avoid creating custom UI components when Ant Design has equivalent
- ‚ùå Components NEVER directly access database or environment variables

**Frontend State Boundaries:**
- **Authentication State:** Managed in `useAuth` hook, accessed via Context
- **Chat State:** Local component state + React hooks
- **API Client State:** Token stored in localStorage, managed by interceptors
- **WebSocket State:** Managed in `useWebSocket` hook

**Backend Layer Boundaries:**
```
Router Layer (FastAPI endpoints)
  ‚Üì calls
Service Layer (business logic)
  ‚Üì calls
Model Layer (database operations via ORM)
  ‚Üì accesses
Database (PostgreSQL)
```

**Rules:**
- ‚úÖ Routers call services, never access models directly
- ‚úÖ Services contain business logic, call models for data
- ‚úÖ Models use SQLAlchemy ORM, no raw SQL
- ‚ùå Routers NEVER directly access database
- ‚ùå Models NEVER contain business logic

#### Service Boundaries

**Auth Service** (`backend/app/services/auth_service.py`):
- **Responsibilities:** User registration, login, JWT token creation, password hashing
- **Dependencies:** User model, JWT handler, password utilities
- **Exposes:** `register_user()`, `authenticate_user()`, `create_token()`

**Chat Service** (`backend/app/services/chat_service.py`):
- **Responsibilities:** Chat session management, message CRUD, LangChain integration
- **Dependencies:** ChatSession model, Message model, LangChain chain factory
- **Exposes:** `create_session()`, `send_message()`, `get_history()`

**User Service** (`backend/app/services/user_service.py`):
- **Responsibilities:** User profile management, user lookup
- **Dependencies:** User model
- **Exposes:** `get_user_by_id()`, `get_user_by_username()`, `update_user()`

**LangChain Service** (`backend/app/langchain_core/chain.py`):
- **Responsibilities:** LLM chain configuration, prompt management, memory handling
- **Dependencies:** OpenAI API, LangChain libraries
- **Exposes:** `create_chain()`, `stream_response()`, `get_chat_history()`

#### Data Boundaries

**Database Schema Boundaries:**
- **Users Table:** User authentication and profile data
- **Chat Sessions Table:** Chat conversation metadata
- **Messages Table:** Individual chat messages (user + assistant)
- **Relationships:** users ‚Üí chat_sessions (1:many), chat_sessions ‚Üí messages (1:many)

**Foreign Key Constraints:**
```sql
chat_sessions.user_id ‚Üí users.id (ON DELETE CASCADE)
messages.session_id ‚Üí chat_sessions.id (ON DELETE CASCADE)
```

**Data Access Patterns:**
- **Read Operations:** Service layer queries via SQLAlchemy ORM
- **Write Operations:** Service layer creates/updates/deletes, commits transaction
- **Migrations:** Alembic manages schema changes, never manual DDL

**Caching Boundaries (Future Enhancement):**
- **Session Cache:** Redis for user sessions
- **Query Cache:** Frequently accessed user data
- **Rate Limit Cache:** API request counters per user/IP

### Requirements to Structure Mapping

#### Feature/Epic Mapping

**Epic: User Authentication & Authorization**
- **Frontend Pages:** `frontend/src/app/(auth)/login/page.tsx`, `frontend/src/app/(auth)/register/page.tsx`
- **Frontend Components:** `frontend/src/components/auth/LoginForm.tsx`, `frontend/src/components/auth/RegisterForm.tsx`, `frontend/src/components/auth/AuthGuard.tsx`
- **Frontend Hooks:** `frontend/src/hooks/useAuth.ts`
- **Frontend Utils:** `frontend/src/lib/auth.ts`, `frontend/src/lib/api-client.ts`
- **Backend Router:** `backend/app/auth/router.py`
- **Backend Services:** `backend/app/services/auth_service.py`
- **Backend Models:** `backend/app/models/user.py`
- **Backend Schemas:** `backend/app/schemas/auth.py`, `backend/app/schemas/user.py`
- **Backend Utils:** `backend/app/auth/jwt_handler.py`, `backend/app/auth/password.py`
- **Database:** `users` table, Alembic migration in `backend/alembic/versions/001_create_users.py`
- **Tests:** `backend/tests/test_auth.py`, `frontend/__tests__/integration/auth-flow.test.tsx`

**Epic: Chat Interface & Real-time Communication**
- **Frontend Pages:** `frontend/src/app/chat/page.tsx`, `frontend/src/app/chat/[sessionId]/page.tsx`
- **Frontend Components:** `frontend/src/components/chat/ChatInterface.tsx`, `frontend/src/components/chat/MessageBubble.tsx`, `frontend/src/components/chat/ChatInput.tsx`, `frontend/src/components/chat/SessionList.tsx`
- **Frontend Hooks:** `frontend/src/hooks/useChat.ts`, `frontend/src/hooks/useWebSocket.ts`
- **Frontend Utils:** `frontend/src/lib/websocket.ts`
- **Backend Router:** `backend/app/chat/router.py`, `backend/app/chat/websocket.py`
- **Backend Services:** `backend/app/services/chat_service.py`
- **Backend Models:** `backend/app/models/chat_session.py`, `backend/app/models/message.py`
- **Backend Schemas:** `backend/app/schemas/chat.py`
- **Database:** `chat_sessions`, `messages` tables, Alembic migrations
- **Tests:** `backend/tests/test_chat.py`, `frontend/__tests__/e2e/chat.spec.ts`

**Epic: LangChain AI Integration**
- **Backend Service:** `backend/app/langchain_core/chain.py`, `backend/app/langchain_core/prompts.py`, `backend/app/langchain_core/memory.py`, `backend/app/langchain_core/callbacks.py`
- **Backend Integration:** Called from `backend/app/services/chat_service.py`
- **Configuration:** OpenAI API key in `backend/.env`
- **Tests:** `backend/tests/test_langchain.py`

#### Cross-Cutting Concerns

**Logging & Monitoring**
- **Backend:** `backend/app/utils/logger.py` (centralized logging configuration)
- **Usage:** Imported in all routers and services
- **Format:** JSON structured logs with timestamp, level, service, component, message
- **Output:** Console (development), log files (production)

**Error Handling**
- **Backend:** `backend/app/utils/exceptions.py` (custom exception classes)
- **Frontend:** Try-catch-finally blocks in all API calls with error state management
- **HTTP Errors:** FastAPI HTTPException with standardized detail format
- **User Display:** User-friendly error messages in frontend, technical errors logged on backend

**Environment Configuration**
- **Root:** `.env.example` (template for all services)
- **Frontend:** `frontend/.env.local` (NEXT_PUBLIC_* variables)
- **Backend:** `backend/.env` (DATABASE_URL, SECRET_KEY, OPENAI_API_KEY)
- **Docker:** Environment variables injected via docker-compose.yml

**API Documentation**
- **Backend:** FastAPI auto-generated at `/docs` (Swagger UI) and `/redoc` (ReDoc)
- **Manual Docs:** `docs/api/endpoints.md` (high-level overview)
- **Schemas:** Pydantic models serve as schema documentation

**Type Definitions**
- **Frontend:** TypeScript interfaces in `frontend/src/types/` (auth.types.ts, chat.types.ts, common.types.ts)
- **Backend:** Pydantic schemas in `backend/app/schemas/` (user.py, chat.py, auth.py)
- **Sharing:** No code sharing between frontend/backend, but conceptually aligned types

### Integration Points

#### Internal Communication

**Frontend Component Communication:**
```
User Action in Component
  ‚Üì
Event Handler (e.g., onClick, onSubmit)
  ‚Üì
Custom Hook (e.g., useAuth, useChat)
  ‚Üì
API Client (lib/api-client.ts)
  ‚Üì
HTTP Request with JWT token
  ‚Üì
Nginx Reverse Proxy
  ‚Üì
Backend API
```

**Backend Layer Communication:**
```
FastAPI Router receives request
  ‚Üì
Dependency Injection (JWT validation, DB session)
  ‚Üì
Service Layer method called
  ‚Üì
Business logic executed
  ‚Üì
Model Layer accessed (SQLAlchemy ORM)
  ‚Üì
Database query executed
  ‚Üì
Results bubbled back up through layers
  ‚Üì
Pydantic schema serialization
  ‚Üì
JSON response returned
```

**WebSocket Communication:**
```
Frontend WebSocket Connection (useWebSocket hook)
  ‚Üì bidirectional
Backend WebSocket Handler (chat/websocket.py)
  ‚Üì
LangChain Streaming (langchain_core/chain.py)
  ‚Üì streams tokens
Frontend receives token-by-token
  ‚Üì
UI updates in real-time (ChatInterface)
```

#### External Integrations

**OpenAI API Integration:**
- **Location:** `backend/app/langchain_core/chain.py`
- **Protocol:** HTTPS REST API
- **Authentication:** API key in environment variable `OPENAI_API_KEY`
- **Models:** GPT-4, GPT-3.5-turbo (configurable)
- **Usage:** LangChain wrapper for chat completion, streaming support
- **Error Handling:** Retry logic, rate limit handling, fallback responses

**PostgreSQL Database:**
- **Connection:** SQLAlchemy engine with connection string from `DATABASE_URL`
- **Protocol:** PostgreSQL wire protocol (port 5432)
- **Pooling:** SQLAlchemy connection pool (max 20 connections)
- **Migrations:** Alembic for schema versioning
- **Backup:** Docker volume persistence, manual backup scripts (future)

**Nginx Reverse Proxy:**
- **Configuration:** `nginx/nginx.conf`
- **Routing Rules:**
  - `/` ‚Üí `frontend:3000` (Next.js)
  - `/api/*` ‚Üí `backend:8000/api/*` (FastAPI)
  - `/api/chat/ws` ‚Üí `backend:8000/api/chat/ws` (WebSocket upgrade)
- **Security:** Rate limiting, security headers, CORS handling

#### Data Flow

**User Registration Flow:**
```
1. User fills registration form (frontend/src/app/(auth)/register/page.tsx)
2. Form submission ‚Üí apiClient.register() (frontend/src/lib/api-client.ts)
3. POST /api/auth/register ‚Üí Nginx ‚Üí Backend
4. auth/router.py::register_user()
5. auth_service.py::register_user() (hash password)
6. models/user.py ‚Üí INSERT into users table
7. Commit transaction
8. Return UserResponse (Pydantic schema)
9. Frontend receives success ‚Üí Navigate to /login
```

**Chat Message Flow:**
```
1. User types message (frontend/src/components/chat/ChatInput.tsx)
2. Send via WebSocket (frontend/src/hooks/useWebSocket.ts)
3. WebSocket message ‚Üí Nginx (upgrade connection) ‚Üí Backend
4. chat/websocket.py::handle_message()
5. chat_service.py::send_message()
6. Save user message to database (models/message.py)
7. langchain_core/chain.py::stream_response()
8. OpenAI API call with streaming
9. Tokens streamed back through WebSocket
10. Frontend receives tokens ‚Üí Update ChatInterface in real-time
11. Complete response saved to database
12. UI shows full conversation
```

**Authentication Flow:**
```
1. User logs in (frontend/src/app/(auth)/login/page.tsx)
2. POST /api/auth/login with credentials
3. auth/router.py::login()
4. auth_service.py::authenticate_user() (verify password)
5. auth/jwt_handler.py::create_access_token()
6. Return JWT token
7. Frontend stores token in localStorage
8. api-client.ts interceptor adds token to all requests
9. Protected route request includes "Authorization: Bearer {token}"
10. Backend auth/dependencies.py::get_current_user() validates token
11. Request processed with authenticated user context
```

### File Organization Patterns

#### Configuration Files

**Root Level:**
- **docker-compose.yml:** Development orchestration (4 services: frontend, backend, nginx, db)
- **docker-compose.prod.yml:** Production configuration with optimized settings
- **.env.example:** Template for all environment variables across services
- **.gitignore:** Excludes node_modules, __pycache__, .env, build outputs

**Frontend Configuration:**
- **next.config.js:** Next.js build configuration, environment variables, image optimization
- **tailwind.config.js:** Tailwind CSS theme, colors, spacing, plugins
- **tsconfig.json:** TypeScript compiler options, path aliases (@/*)
- **postcss.config.js:** PostCSS plugins for Tailwind
- **.eslintrc.json:** Linting rules for TypeScript/React
- **.env.local:** Local development environment variables (not committed)

**Backend Configuration:**
- **pyproject.toml:** Python project metadata, dependencies, build system
- **requirements.txt:** Production dependencies
- **requirements-dev.txt:** Development dependencies (pytest, black, flake8)
- **pytest.ini:** Pytest configuration, test discovery patterns
- **alembic.ini:** Alembic migration configuration
- **.env:** Local environment variables (DATABASE_URL, SECRET_KEY, OPENAI_API_KEY)

**Nginx Configuration:**
- **nginx.conf:** Reverse proxy rules, upstream definitions, security headers, rate limiting

#### Source Organization

**Frontend Source (frontend/src/):**
- **app/:** Next.js App Router, file-system routing
  - **layout.tsx:** Root layout with providers, metadata
  - **page.tsx:** Homepage
  - **(auth)/:** Route group for authentication pages (shared layout possible)
  - **chat/:** Chat pages with dynamic routes ([sessionId])
- **components/:** Reusable React components
  - **ui/:** Generic UI primitives (Button, Input, Card)
  - **auth/:** Authentication-specific components
  - **chat/:** Chat-specific components
- **lib/:** Core utilities and configurations
  - **api-client.ts:** Axios instance with interceptors
  - **auth.ts:** Auth helper functions
  - **websocket.ts:** WebSocket connection manager
- **hooks/:** Custom React hooks (use* prefix)
- **types/:** TypeScript type definitions (*.types.ts)
- **utils/:** Helper functions (validators, formatters, date helpers)

**Backend Source (backend/app/):**
- **main.py:** FastAPI application entry point, CORS configuration, router registration
- **config.py:** Settings management with Pydantic BaseSettings
- **dependencies.py:** Shared FastAPI dependencies (DB session, current user)
- **Feature Modules (auth/, chat/, users/):**
  - **router.py:** FastAPI route definitions
  - **schemas.py:** Pydantic request/response models (optional, can be in schemas/)
  - **dependencies.py:** Module-specific dependencies
- **models/:** SQLAlchemy ORM models (database tables)
- **schemas/:** Pydantic schemas for request/response validation
- **services/:** Business logic layer (pure Python, no FastAPI dependencies)
- **langchain_core/:** LangChain integration (chain, prompts, memory, callbacks)
- **database/:** Database session management, base model
- **utils/:** Utilities (logger, custom exceptions)

#### Test Organization

**Frontend Tests:**
- **Co-located Tests:** `ComponentName.test.tsx` next to `ComponentName.tsx` in components/
- **Hook Tests:** `useHookName.test.ts` next to `useHookName.ts` in hooks/
- **Integration Tests:** `__tests__/integration/` for multi-component flows
- **E2E Tests:** `__tests__/e2e/` for full user journey tests (Playwright/Cypress)

**Backend Tests:**
- **Unit Tests:** `tests/test_*.py` mirroring module structure
  - `tests/test_auth.py` ‚Üí Tests for `app/auth/`
  - `tests/test_chat.py` ‚Üí Tests for `app/chat/`
  - `tests/test_models.py` ‚Üí Tests for `app/models/`
- **Integration Tests:** `tests/integration/` for API endpoint tests
- **Fixtures:** `tests/conftest.py` for pytest fixtures (test database, test client)

#### Asset Organization

**Static Assets (frontend/public/):**
- **favicon.ico:** Browser tab icon
- **images/:** Static images (logos, backgrounds)
- **icons/:** SVG icons, icon fonts

**Build Outputs:**
- **Frontend:** `frontend/.next/` (Next.js build output, gitignored)
- **Backend:** `backend/__pycache__/`, `backend/.pytest_cache/` (gitignored)

**Docker Volumes:**
- **postgres_data:** Database persistence
- **logs/:** Application log files (mounted volume)

### Development Workflow Integration

#### Development Server Structure

**Starting Development Environment:**
```bash
# From project root
docker-compose up --build

# Services start:
# - PostgreSQL (port 5432)
# - Backend FastAPI (port 8000, hot reload)
# - Frontend Next.js (port 3000, hot reload)
# - Nginx (port 80, proxies to services)
```

**Development URLs:**
- **Frontend:** http://localhost (or http://localhost:3000 directly)
- **Backend API:** http://localhost/api
- **API Docs:** http://localhost/api/docs (Swagger UI)
- **Database:** localhost:5432 (accessible for debugging)

**Hot Reload:**
- **Frontend:** Next.js dev server watches `frontend/src/`, rebuilds on change
- **Backend:** Uvicorn with `--reload` watches `backend/app/`, restarts on change
- **Docker:** Volumes mounted for source code, changes reflected immediately

#### Build Process Structure

**Frontend Build:**
```bash
cd frontend
npm run build  # Creates optimized production build in .next/

# Docker build:
# Dockerfile uses multi-stage build
# - Stage 1: Install dependencies
# - Stage 2: Build Next.js app
# - Stage 3: Production runtime with minimal image
```

**Backend Build:**
```bash
cd backend
pip install -r requirements.txt

# Docker build:
# Dockerfile:
# - Base image: python:3.11-slim
# - Install dependencies
# - Copy source code
# - Run Uvicorn server
```

**Database Migrations:**
```bash
cd backend
alembic revision --autogenerate -m "Description"
alembic upgrade head

# In Docker:
docker-compose exec backend alembic upgrade head
```

#### Deployment Structure

**Production Deployment (Docker Compose):**
```bash
# Build production images
docker-compose -f docker-compose.prod.yml build

# Start services in detached mode
docker-compose -f docker-compose.prod.yml up -d

# Run database migrations
docker-compose exec backend alembic upgrade head

# Check service health
docker-compose ps
docker-compose logs -f
```

**Environment Variables (Production):**
- **Frontend:** `NEXT_PUBLIC_API_URL=https://yourdomain.com/api`
- **Backend:** `DATABASE_URL=postgresql://produser:password@db:5432/chatbot_prod`, `SECRET_KEY={64-char-hex}`, `DEBUG=False`
- **Nginx:** SSL certificates in `nginx/ssl/`, update nginx.conf for HTTPS

**Scaling (Future):**
- **Horizontal:** Multiple backend replicas behind Nginx load balancer
- **Vertical:** Increase Docker resource limits (CPU, memory)
- **Database:** Read replicas, connection pooling with PgBouncer
- **Kubernetes:** Migrate from Docker Compose to K8s for production-grade orchestration

---

## Architecture Validation Results

### Coherence Validation ‚úÖ

**Decision Compatibility:**
All architectural decisions are fully compatible and work together seamlessly. Technology stack verification confirms:
- Next.js 14+ (Node.js) and FastAPI (Python 3.11+) communicate effectively via REST API and WebSocket
- PostgreSQL 15+ with SQLAlchemy 2.0+ provides robust data persistence
- Docker 24+ with Docker Compose 2+ enables reliable multi-service orchestration
- Nginx 1.25+ serves as an effective reverse proxy for all services
- LangChain 0.1+ with OpenAI GPT-4 delivers AI-powered conversational capabilities
- JWT authentication (python-jose) with bcrypt (passlib) ensures secure user authentication
- All specified versions are mutually compatible with no conflicts

**Pattern Consistency:**
Implementation patterns fully support architectural decisions:
- Database naming (snake_case) aligns with PostgreSQL conventions
- Frontend JSON (camelCase) follows TypeScript/JavaScript standards
- Backend Python (snake_case) adheres to PEP 8 guidelines
- Pydantic automatic conversion bridges frontend/backend naming differences seamlessly
- File organization patterns match Next.js App Router and FastAPI best practices
- Error handling patterns (try-catch-finally) are consistent across both frontend and backend
- Loading state patterns (`isLoading` boolean) standardized across all components
- Authentication flow (OAuth2 Bearer) consistently implemented throughout the stack

**Structure Alignment:**
Project structure perfectly supports all architectural decisions:
- Frontend structure (app/, components/, lib/, hooks/) enables Next.js App Router patterns
- Backend structure (auth/, chat/, models/, services/) supports modular FastAPI architecture
- Test organization (co-located frontend tests, mirrored backend tests) facilitates comprehensive testing
- Docker structure enables seamless 4-service orchestration (frontend, backend, database, nginx)
- All boundaries (API, Component, Service, Data) are properly isolated and well-defined
- Integration points are clearly mapped with explicit communication patterns

### Requirements Coverage Validation ‚úÖ

**Functional Requirements Coverage:**

**User Authentication & Authorization:**
- ‚úÖ JWT token-based authentication with HS256 algorithm
- ‚úÖ Bcrypt password hashing (cost factor 12) for secure storage
- ‚úÖ Architecture: `backend/app/auth/` module + `frontend/src/app/(auth)/` pages
- ‚úÖ Database: `users` table with indexed username and email columns
- ‚úÖ Complete registration and login flows documented with code examples

**Chat Interface:**
- ‚úÖ Real-time chat interface using React components and WebSocket
- ‚úÖ Architecture: `frontend/src/components/chat/` + `backend/app/chat/`
- ‚úÖ Database: `chat_sessions` and `messages` tables with cascading relationships
- ‚úÖ Complete data flow from user input to AI response documented

**AI-Powered Responses (LangChain):**
- ‚úÖ LangChain 0.1+ integration with OpenAI GPT-4
- ‚úÖ Architecture: `backend/app/langchain_core/` module with chain, prompts, memory, callbacks
- ‚úÖ Streaming responses via WebSocket for real-time user experience
- ‚úÖ Chain factory pattern for flexible LLM configuration

**Chat History & Session Management:**
- ‚úÖ PostgreSQL with normalized schema (users ‚Üí chat_sessions ‚Üí messages)
- ‚úÖ Foreign key constraints with cascading deletes
- ‚úÖ API endpoints: GET /api/chat/sessions, GET /api/chat/sessions/{id}/messages
- ‚úÖ Complete CRUD patterns for session and message management

**Real-Time Communication:**
- ‚úÖ WebSocket implementation with FastAPI native support
- ‚úÖ React hooks (`useWebSocket`) for frontend connection management
- ‚úÖ Architecture: `backend/app/chat/websocket.py` + `frontend/src/hooks/useWebSocket.ts`
- ‚úÖ JSON message format with type field and payload structure defined

**Non-Functional Requirements Coverage:**

**Security:**
- ‚úÖ JWT authentication with 30-minute token expiration
- ‚úÖ Bcrypt password hashing with cost factor 12
- ‚úÖ Input validation using Pydantic (backend) and Zod (frontend)
- ‚úÖ SQL injection prevention via SQLAlchemy ORM parameterized queries
- ‚úÖ XSS prevention through output encoding
- ‚úÖ HTTPS/TLS for production deployment
- ‚úÖ Security headers configured in Nginx (X-Frame-Options, X-Content-Type-Options, etc.)
- ‚úÖ Rate limiting at Nginx level (5 req/min for auth, 10 req/sec for chat)

**Performance:**
- ‚úÖ Database indexes on all foreign keys and frequently queried columns
- ‚úÖ SQLAlchemy connection pooling (max 20 connections per instance)
- ‚úÖ LangChain streaming reduces perceived latency for AI responses
- ‚úÖ Next.js automatic code splitting and image optimization
- ‚úÖ Nginx gzip compression for text content
- ‚úÖ WebSocket for efficient real-time communication

**Scalability:**
- ‚úÖ Horizontal scaling: Multiple backend replicas behind Nginx load balancer
- ‚úÖ Stateless authentication (JWT) enables seamless multi-instance deployment
- ‚úÖ Database connection pooling supports high concurrency
- ‚úÖ Docker containerization for elastic scaling
- ‚úÖ Future enhancements: Redis caching, database read replicas, Kubernetes migration

**Maintainability:**
- ‚úÖ Clear separation of concerns: Router ‚Üí Service ‚Üí Model (backend), Pages ‚Üí Components ‚Üí UI (frontend)
- ‚úÖ Comprehensive implementation patterns prevent inconsistencies
- ‚úÖ Consistent naming conventions across all layers
- ‚úÖ Co-located tests for easy maintenance
- ‚úÖ Alembic database migrations for schema evolution
- ‚úÖ Type safety with TypeScript and Pydantic

**Deployability:**
- ‚úÖ Docker Compose for one-command deployment (`docker-compose up`)
- ‚úÖ Environment variable configuration with .env.example templates
- ‚úÖ Health check endpoints (/health, /health/detailed)
- ‚úÖ Automated database migrations (Alembic)
- ‚úÖ Separate production configuration (docker-compose.prod.yml)

### Implementation Readiness Validation ‚úÖ

**Decision Completeness:**
- ‚úÖ All critical architectural decisions documented with specific technology versions
- ‚úÖ Technology stack: 10+ technologies with exact version requirements (Next.js 14+, Python 3.11+, PostgreSQL 15+, etc.)
- ‚úÖ Implementation patterns: 18 potential conflict points identified and resolved
- ‚úÖ Code examples provided for all major patterns (registration flow, authentication, chat message handling)
- ‚úÖ Good vs. anti-pattern examples included for clarity
- ‚úÖ Rationale documented for each major decision (database choice, JWT storage, WebSocket usage, etc.)

**Structure Completeness:**
- ‚úÖ Complete directory tree defined with 280+ lines of specific structure
- ‚úÖ All configuration files explicitly listed (package.json, Dockerfile, nginx.conf, tsconfig.json, etc.)
- ‚úÖ Frontend structure: 40+ files/directories specified (app/, components/, lib/, hooks/, types/, utils/)
- ‚úÖ Backend structure: 35+ files/directories specified (auth/, chat/, models/, schemas/, services/, langchain_core/)
- ‚úÖ Test organization fully specified (co-located .test.tsx files, mirrored backend tests/)
- ‚úÖ Docker infrastructure defined (4 services, volumes, networks, health checks)

**Pattern Completeness:**
- ‚úÖ Naming conventions comprehensive: Database (snake_case), API (RESTful plural), Frontend (camelCase), Backend (snake_case)
- ‚úÖ Structure patterns: Project organization, file naming, test organization
- ‚úÖ Format patterns: API responses (direct Pydantic for success, envelope for errors), JSON field naming, date/time (ISO 8601)
- ‚úÖ Communication patterns: Loading states (`isLoading`), error handling (try-catch-finally), authentication flow (OAuth2 Bearer)
- ‚úÖ Process patterns: Complete flows for registration, login, chat messaging with code examples
- ‚úÖ Enforcement guidelines: 10 mandatory rules + verification checklist + pattern update process

**Integration Points Defined:**
- ‚úÖ Frontend ‚Üî Backend: HTTP REST API + WebSocket with JWT authentication
- ‚úÖ Backend ‚Üî Database: SQLAlchemy ORM with connection pooling
- ‚úÖ Backend ‚Üî OpenAI: LangChain integration with streaming support
- ‚úÖ All Services ‚Üî Nginx: Reverse proxy routing with rate limiting and security headers
- ‚úÖ Docker networking: Bridge network with service discovery by name

### Gap Analysis Results

**Critical Gaps: NONE ‚úÖ**
No blocking architectural decisions missing. All critical paths from user input to AI response are fully specified.

**Important Gaps: 2 Minor Items (Defer to Implementation Phase)**

1. **Logging Strategy Detail (Low Priority)**
   - **Current State:** Basic logging configuration mentioned in utils/logger.py
   - **Enhancement Opportunity:** Could add structured logging format examples, log rotation policies, log aggregation strategy
   - **Impact:** Would improve debugging efficiency and production monitoring
   - **Recommendation:** Defer to implementation phase. Use console logging in development, file logging in production. Python standard logging module with INFO/WARNING/ERROR levels is sufficient for initial implementation.

2. **CI/CD Pipeline Specifics (Low Priority)**
   - **Current State:** GitHub Actions workflow file location specified in project structure (.github/workflows/ci.yml)
   - **Enhancement Opportunity:** Could add example workflow YAML with test/build/deploy stages, Docker image pushing, automated deployment
   - **Impact:** Would accelerate initial setup and enable continuous deployment
   - **Recommendation:** Defer to implementation phase. Focus on core application functionality first, then add CI/CD automation in sprint 2-3.

**Nice-to-Have Gaps: 3 Items (Future Enhancements)**

1. **Development Tooling Recommendations**
   - VSCode extensions (ESLint, Prettier, Python, Docker)
   - Docker Desktop setup guide
   - Database GUI tools (pgAdmin, DBeaver)
   - **Status:** Not blocking, adds developer convenience

2. **Performance Benchmarking Baseline**
   - Target response times documented (2s page load, 3s LLM response p95)
   - Enhancement: Baseline measurement plan with k6 or Locust
   - **Status:** Defer to post-implementation testing phase

3. **Disaster Recovery Plan**
   - Database backup automation not detailed
   - Enhancement: Automated daily backups, point-in-time recovery, backup retention policies
   - **Status:** Defer to production deployment phase

**Gap Resolution Status:**
All identified gaps are non-blocking. The architecture is complete and ready for implementation. Minor enhancements can be addressed iteratively during or after initial implementation.

### Validation Issues Addressed

**No Critical Issues Found ‚úÖ**

During comprehensive validation, no critical issues were identified. All architectural decisions are coherent, all requirements are covered, and the architecture is ready for AI agent implementation.

**Minor Clarifications Made:**

1. **Environment Variable Management:** Clarified that .env files are gitignored, .env.example serves as template, Docker Compose injects variables into containers.

2. **Test Strategy:** Confirmed co-location pattern for frontend component tests, mirrored structure for backend tests, integration tests in separate directories.

3. **WebSocket Authentication:** Specified that token is passed as query parameter (?token={access_token}) for WebSocket connections since headers aren't available in browser WebSocket API.

4. **Date/Time Handling:** Explicitly documented UTC storage, ISO 8601 transport, local conversion only for display.

All clarifications have been incorporated into the architecture document.

### Architecture Completeness Checklist

**‚úÖ Requirements Analysis**
- [x] Project context thoroughly analyzed from PRD, project planning, and brainstorming documents
- [x] Scale and complexity assessed (Medium-High: 8-10 components, 8-10 weeks, 2-4 developers)
- [x] Technical constraints identified (learning playground focus, production-ready quality, budget-conscious)
- [x] Cross-cutting concerns mapped (authentication, logging, error handling, environment configuration)

**‚úÖ Starter Template Evaluation**
- [x] Next.js CLI template selected for frontend (`npx create-next-app@latest`)
- [x] FastAPI manual setup for backend (requirements.txt with specific dependencies)
- [x] Docker Compose for orchestration (4 services: frontend, backend, database, nginx)
- [x] PostgreSQL for database (official docker image: postgres:15-alpine)

**‚úÖ Architectural Decisions**
- [x] Critical decisions documented with technology versions and rationale
- [x] Technology stack fully specified (Next.js 14+, FastAPI, PostgreSQL 15+, Docker 24+, Nginx 1.25+, LangChain 0.1+)
- [x] Integration patterns defined (REST API, WebSocket, JWT authentication, SQLAlchemy ORM)
- [x] Performance considerations addressed (indexes, connection pooling, streaming, code splitting)
- [x] Security architecture complete (JWT, bcrypt, rate limiting, security headers, input validation)

**‚úÖ Implementation Patterns**
- [x] Naming conventions established for all layers (database, API, frontend code, backend code, files)
- [x] Structure patterns defined (project organization, module boundaries, test organization)
- [x] Communication patterns specified (loading states, error handling, authentication flow)
- [x] Process patterns documented (registration, login, chat messaging with complete code examples)
- [x] Enforcement guidelines provided (10 mandatory rules, verification checklist, update process)

**‚úÖ Project Structure**
- [x] Complete directory structure defined (280+ lines with all files and directories)
- [x] Component boundaries established (Frontend: Pages ‚Üí Features ‚Üí UI, Backend: Router ‚Üí Service ‚Üí Model)
- [x] Integration points mapped (Frontend ‚Üî Backend ‚Üî Database ‚Üî OpenAI, all via defined protocols)
- [x] Requirements to structure mapping complete (authentication ‚Üí auth/, chat ‚Üí chat/, AI ‚Üí langchain_core/)

**‚úÖ Validation & Readiness**
- [x] Coherence validation passed (all decisions compatible, patterns consistent, structure aligned)
- [x] Requirements coverage validated (100% of FRs and NFRs architecturally supported)
- [x] Implementation readiness confirmed (AI agents can implement with clear, specific guidance)
- [x] Gap analysis completed (no critical gaps, minor items documented for future enhancement)

### Architecture Readiness Assessment

**Overall Status:** ‚úÖ **READY FOR IMPLEMENTATION**

**Confidence Level:** **HIGH**

The architecture has been comprehensively validated across all dimensions:
- **Coherence:** All decisions work together without conflicts
- **Coverage:** 100% of functional and non-functional requirements are architecturally supported
- **Readiness:** AI agents have clear, specific, executable guidance for consistent implementation
- **Completeness:** No critical gaps exist; minor enhancements identified for future iterations

**Key Strengths:**

1. **Technology Stack Clarity:** All technologies specified with exact versions (Next.js 14+, Python 3.11+, PostgreSQL 15+, Docker 24+), eliminating version compatibility uncertainties.

2. **Comprehensive Implementation Patterns:** 18 potential AI agent conflict points identified and resolved with mandatory patterns covering naming, structure, formats, communication, and processes.

3. **Complete Project Structure:** 280+ line directory tree with all files explicitly listed, leaving no ambiguity about where code should be placed.

4. **Requirements Traceability:** Every functional requirement mapped to specific architectural components and file locations, enabling easy verification during implementation.

5. **Security-First Architecture:** JWT authentication, bcrypt hashing, input validation, rate limiting, and security headers built into foundational decisions.

6. **Clear Boundaries:** API boundaries, component boundaries, service boundaries, and data boundaries explicitly defined with enforcement rules.

7. **Scalability Built-In:** Stateless authentication, connection pooling, horizontal scaling capability, Docker containerization support future growth.

8. **Code Examples:** Complete working examples for critical flows (user registration, authentication, chat messaging) demonstrate proper pattern usage.

9. **Developer Experience:** Clear error handling, loading state patterns, type safety (TypeScript + Pydantic), co-located tests improve development velocity.

10. **Deployment Readiness:** Docker Compose configuration, environment variable management, health checks, database migrations enable one-command deployment.

**Areas for Future Enhancement:**

1. **Caching Layer:** Add Redis for session management, rate limiting counters, and frequently accessed data to improve performance at scale.

2. **Database Read Replicas:** Implement read replicas to separate read/write workloads and improve query performance for chat history retrieval.

3. **Kubernetes Migration:** Transition from Docker Compose to Kubernetes for production-grade orchestration, self-healing, and advanced deployment strategies.

4. **Comprehensive Monitoring:** Implement Prometheus + Grafana stack for metrics collection, visualization, and alerting on system health.

5. **Advanced Analytics:** Add analytics dashboard tracking user engagement, conversation topics, AI response quality, and system performance trends.

6. **Multi-Region Deployment:** Expand to multiple geographic regions for lower latency and improved disaster recovery capabilities.

7. **Vector Database Integration:** Add Pinecone or Weaviate for Retrieval Augmented Generation (RAG) to enable custom knowledge base integration.

8. **CI/CD Automation:** Implement comprehensive CI/CD pipeline with automated testing, security scanning, Docker image building, and deployment.

These enhancements are not required for initial implementation but provide a clear roadmap for iterative improvement as the system matures and scales.

### Implementation Handoff

**AI Agent Guidelines:**

All AI agents implementing this architecture MUST:

1. **Follow Architectural Decisions Exactly:** Use the specified technology versions (Next.js 14+, Python 3.11+, PostgreSQL 15+, etc.) without substitution.

2. **Apply Implementation Patterns Consistently:** Adhere to all naming conventions (snake_case database, camelCase frontend, snake_case backend), structure patterns, and communication patterns across all components.

3. **Respect Project Structure:** Place all files in the defined locations. Do not create alternative directory structures.

4. **Honor Boundaries:** Maintain strict separation between layers (Router ‚Üí Service ‚Üí Model on backend, Pages ‚Üí Components ‚Üí UI on frontend). Never bypass layers.

5. **Implement Error Handling Uniformly:** Use try-catch-finally blocks in all API calls, always reset loading states in finally blocks, display user-friendly error messages.

6. **Validate All Inputs:** Use Pydantic schemas on backend, implement client-side validation on frontend, never trust user input.

7. **Follow Authentication Flow:** Implement JWT authentication exactly as specified, store tokens in localStorage (development) or httpOnly cookies (production), include Authorization header in all protected requests.

8. **Use Type Safety:** Define TypeScript interfaces for all data structures on frontend, use Pydantic models for all request/response schemas on backend.

9. **Write Tests:** Co-locate component tests with components on frontend, mirror structure in tests/ directory on backend, aim for comprehensive coverage.

10. **Refer to This Document:** When encountering any architectural question or ambiguity, refer back to this architecture document as the single source of truth.

**First Implementation Priority:**

**Phase 1: Project Initialization (Week 1, Sprint 1)**

```bash
# Step 1: Create project root directory
mkdir langchain
cd langchain

# Step 2: Initialize frontend with Next.js CLI
npx create-next-app@latest frontend --typescript --tailwind --app --src-dir --import-alias "@/*"

# Step 3: Create backend structure
mkdir -p backend/app/{auth,chat,users,models,schemas,services,langchain_core,database,utils}
mkdir -p backend/tests/{integration}
mkdir -p backend/alembic/versions

# Step 4: Create backend requirements.txt
cat > backend/requirements.txt << EOF
fastapi==0.104.0
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
alembic==1.12.1
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
langchain==0.1.0
langchain-openai==0.0.2
pydantic==2.5.0
pydantic-settings==2.1.0
EOF

# Step 5: Create docker-compose.yml
# (Use the complete Docker Compose configuration from Project Structure section)

# Step 6: Create Nginx configuration
mkdir nginx
# (Use the nginx.conf from Nginx Service section)

# Step 7: Set up environment variables
cp .env.example .env
# Edit .env with actual values (DATABASE_URL, SECRET_KEY, OPENAI_API_KEY)

# Step 8: Start development environment
docker-compose up --build

# Step 9: Run initial database migration
docker-compose exec backend alembic revision --autogenerate -m "Initial schema"
docker-compose exec backend alembic upgrade head

# Step 10: Verify services
# Frontend: http://localhost
# Backend API: http://localhost/api/docs
# Database: localhost:5432
```

**Implementation Sequence:**

1. **Week 1 (Sprint 1):** Project initialization, database schema, basic Docker setup
2. **Week 2 (Sprint 1):** User authentication (registration, login, JWT) on backend
3. **Week 3 (Sprint 2):** Authentication UI on frontend, protected routes
4. **Week 4 (Sprint 2):** Chat session management (backend CRUD, database)
5. **Week 5 (Sprint 3):** LangChain integration, OpenAI connection, streaming
6. **Week 6 (Sprint 3):** Chat interface UI, WebSocket connection, real-time messaging
7. **Week 7 (Sprint 4):** Testing (unit, integration, e2e), bug fixes
8. **Week 8 (Sprint 4):** Production deployment configuration, documentation, polish

**Success Criteria for Implementation:**

- ‚úÖ All tests passing (unit, integration, e2e)
- ‚úÖ User can register, login, create chat session, send message, receive AI response
- ‚úÖ Architecture patterns followed consistently across all code
- ‚úÖ No architectural decisions violated during implementation
- ‚úÖ All services running successfully in Docker containers
- ‚úÖ API documentation accessible at /api/docs
- ‚úÖ Production-ready with environment configuration and deployment scripts

---

## Architecture Document Complete ‚úÖ

This architecture has been validated and is ready to guide AI agents through consistent, high-quality implementation of the LangChain Chatbot project.

**Document Version:** 1.0  
**Status:** VALIDATED & APPROVED  
**Date:** December 1, 2025  
**Next Phase:** Implementation (Sprint 1, Week 1)
